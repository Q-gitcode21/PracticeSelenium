                ---------------Find element command---------------

1.Clicking an element must satisfy two conditions:
-- visible: the element is in visible area of the browser and not covered by another element
-- enable: the element is in an enable state
Example : A hidden button (display:none) or disabled input can not be clicked.
2.Visible
An element is considered visible when it is attached to the HTML DOM
and can be seen in some way(e.g,not hidden)
~ findElement and isDisplay can be used to check visibility
Example : A hidden button (display:none) is not visible
3.Present
The element is attached to the HTML DOM,regardless of whether it is visible
4.Get text
Get text only from text box and text area
5.Horizontal position
the horizontal distance (from the left edge of the page).
6.Vertical position
the vertical distance (from the top edge of the page).

                        ---------------Xpath---------------

I. Xpath : XML Path Language
- use for finding any element on a webpage using HTML DOM structure
- both HTML or XML document
II. Structure
1.Path
- / : absolute path
- // : relative path
2.Basic syntax
//tag[@attribute='value']
//tag[target='value'] (target = text(), @attr, ...)
//tag[function(target,'value')] (e.g., contains, starts-with)
3.Expression: And, Or
Ex : //input[@type='submit' and @name='btnLogin’]
4.Index
Xpath start index at 1
5.Axes
- Syntax : "/axis::tagname"
Some axes most use : child::, parent::,ancestor::,descendant::,following-sibling::,preceding-sibling::
III. Some methods
text() ,start-with, contains

                        ---------------CSS Selector---------------

I. CSS Selector
Another method of Selenium to find elements
II.Structure
1.Syntax
node[attribute_name = ‘attribute_value’]
node is the tag name of the HTML element, which needs to locate.
2.Some syntaxs

1/tagname
EX: input, button
id
Ex: #username

2/class
Ex: .btn-primary

3/attribute
Ex: input[type='text']

4/mixed
Ex: button.btn[type='submit']

                ---------------Web drive wait---------------

I.Implicit Wait
- Apply to all element in web drive

- Operation : Selenium must find element in the first time.
If it not found the element, active the flag wait about 'X' timeout.
After that,Selenium find element one again.
>> With implicit wait, the find element method is used twice.

- Syntax: driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));

- Note : usual set up only once after initialize drive

II.Fluent Wait (Smart wait)
- Allow config time out , polling interval , ignore exception
- Operation :
1.Selenium find element the first time.
2.If not found, active flag wait.
3.Then Selenium check element again after every polling interval
4.Repeat until timeout or until element is found.
5.If timeout, throw exception.
- Syntax :
Wait<WebDriver> wait = new FluentWait<>(driver)
        .withTimeout(Duration.ofSeconds(20))
        .pollingEvery(Duration.ofMillis(500))
        .ignoring(NoSuchElementException.class);

WebElement we = wait.until(new Function<WebDriver, WebElement>() {
       @Override
        public WebElement apply(WebDriver webDriver) {
          return driver.findElement(findBy(locator));
        }
      });

- Note : only use when you can well control it

III.Web Drive Wait (Explicit Wait)
- Similar to fluent wait because web drive wait extends it
- But it concise,easy to use because it is configured by Slenium
- Apply for one element with a specific condition
- Using WebDriverWait combine with ExpectedConditions.

- Operation :
1.Find element first time
2.If not found element active flag wait
3.Each 500 milliseconds (default) , find element again about duration timeout

- Syntax:
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(15));
            WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("submitBtn")));
            element.click();

- Note : Mostly use

                ---------------Enhance find element with wait---------------

Final Concept for findWebElement
1. Centralize timeout + condition

All keywords (click, inputText, getText…) call findWebElement.

findWebElement is the single entry point handling:
- Locator (via findBy)
- Timeout
- Wait condition

2. Use Enum WaitCondition instead of call ExpectedConditions
Concise when call
Easy to extend (just add new enum constant + mapping once).

3. Three overloads of findWebElement
// 1. Default -> use DEFAULT_TIMEOUT, condition = PRESENCE
public WebElement findWebElement(String locator);

// 2. Custom timeout -> still PRESENCE
public WebElement findWebElement(String locator, int timeoutInSeconds);

// 3. Custom condition + custom timeout
public WebElement findWebElement(String locator, WaitCondition condition, int timeoutInSeconds);

4. Enum with static method
public enum WaitCondition {
    PRESENCE,
    VISIBLE,
    CLICKABLE;

    public static ExpectedCondition<WebElement> getCondition(WaitCondition condition, By locator) {
        return switch (condition) {
            case VISIBLE   -> ExpectedConditions.visibilityOfElementLocated(locator);
            case CLICKABLE -> ExpectedConditions.elementToBeClickable(locator);
            default        -> ExpectedConditions.presenceOfElementLocated(locator);
        };
    }
}

5. Implementation in findWebElement
public WebElement findWebElement(String locator, WaitCondition condition, int timeoutInSeconds) {
    By byLocator = findBy(locator);
    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
    return wait.until(WaitCondition.getCondition(condition, byLocator));
}

6. Usage in test
// Default: PRESENCE + DEFAULT_TIMEOUT
WebElement username = findWebElement("id:username");

// Custom timeout
WebElement password = findWebElement("id:password", 20);

// Explicit CLICKABLE + custom timeout
WebElement btn = findWebElement("id:submitBtn", WaitCondition.CLICKABLE, 15);
btn.click();















